# standard library imports
import datetime
import queue
from abc import ABCMeta, abstractmethod
import random
import time

# local package imports
from .event import FillEvent, OrderEvent


class ExecutionHandler(object):
    """
    The ExecutionHandler abstract class handles the interaction
    between a set of order objects generated by a Portfolio and
    the ultimate set of Fill objects that actually occur in the
    market. 

    The handlers can be used to subclass simulated brokerages
    or live brokerages, with identical interfaces. This allows
    strategies to be backtested in a very similar manner to the
    live trading engine.
    """

    __metaclass__ = ABCMeta

    @abstractmethod
    def execute_order(self, event):
        """
        Takes an Order event and executes it, producing
        a Fill event that gets placed onto the Events queue.

        Parameters:
        event - Contains an Event object with order information.
        """
        raise NotImplementedError("Should implement execute_order()")


    
# TODO: increase the complexity of fill simulator to include slipage and market impact
class SimulatedExecutionHandler(ExecutionHandler):
    """
    The simulated execution handler simply converts all order
    objects into their equivalent fill objects automatically
    without latency, slippage or fill-ratio issues.

    This allows a straightforward "first go" test of any strategy,
    before implementation with a more sophisticated execution
    handler.
    """
    
    def __init__(self, events):
        """
        Initialises the handler, setting the event queues
        up internally.

        Parameters:
        events - The Queue of Event objects.
        slippage - The slippage to apply to the conversion from
        Order to Fill.
        market_impact - The market impact to apply to the conversion
        from Order to Fill.
        """
        self.events = events

    def execute_order(self, event):
        """
        Simply converts Order objects into Fill objects naively,
        i.e. without any latency, slippage or fill ratio problems.

        Parameters:
        event - Contains an Event object with order information.
        """
        if event.type == 'ORDER':
<<<<<<< HEAD
<<<<<<< HEAD
            fill_event = FillEvent(datetime.datetime.now(), event.symbol,
                                   'Backtest', event.quantity, event.price)
            self.events.put(fill_event)
=======
            
=======

>>>>>>> f8144ee (calculate market impact and slippage)
            # Calculate slippage based on order size and market volatility
            slippage_amount = self.calculate_slippage(event.quantity, self.calculate_market_volatility(event.symbol))
            market_impact_amount = self.calculate_market_impact(event.quantity)

            # Simulate time latency (adjust latency_value as needed)
            latency_value = 0.005  
            time.sleep(latency_value) 

             # Adjust fill price with slippage and market impact
            fill_price = event.fill_price + slippage_amount + market_impact_amount
            
            fill_event = FillEvent(
                datetime.datetime.utcnow(), event.symbol,
                'ARCA', 
                event.quantity, 
                event.direction,
                fill_price)
            self.events.put(fill_event)
    
    def calculate_market_volatility(self, symbol):
        """
        Calculate market volatility for a given symbol.
        This is a simplified example; in real-world scenarios,
        we would use historical price data or other indicators
        to estimate market volatility.
        """
        # Example: random market volatility between 0.005 and 0.02
        return random.uniform(0.005, 0.02)

    def calculate_slippage(self, order_quantity, market_volatility):
        """
        Calculate slippage based on order size and market volatility
        using a Monte Carlo simulation approach.

        Parameters:
        order_quantity - The quantity of the order.
        market_volatility - The estimated market volatility.

        Returns:
        Simulated slippage amount.
        """
        num_simulations = 1000  # Number of Monte Carlo simulations
        slippage_per_unit_size = 0.0001  # Slippage per unit of order size
        slippage_per_unit_volatility = 0.001  # Slippage per unit of market volatility

        total_slippage = 0.0
        for _ in range(num_simulations):
            # Generate random variations in order size and market volatility
            random_order_variation = random.uniform(0.9, 1.1)
            random_volatility_variation = random.uniform(0.9, 1.1)
            
            # Calculate slippage for this simulation iteration
            simulated_slippage = (
                order_quantity * slippage_per_unit_size * random_order_variation +
                market_volatility * slippage_per_unit_volatility * random_volatility_variation
            )
            
            total_slippage += simulated_slippage

        average_slippage = total_slippage / num_simulations
        return average_slippage
    

    def calculate_market_impact(self, order_quantity):
        """
        Calculate market impact based on order quantity.

        Parameters:
        order_quantity - The quantity of the order.

        Returns:
        Market impact amount.
        """
        # Define market impact factors (adjust these values as needed)
        market_impact_per_unit_size = 0.0002  # Market impact per unit of order size
        max_market_impact = 0.01  # Maximum market impact allowed 
        # Calculate market impact amount
        market_impact_amount = order_quantity * market_impact_per_unit_size

        # Ensure market impact doesn't exceed the maximum allowed
        market_impact_amount = min(market_impact_amount, max_market_impact)
        
        return market_impact_amount
    
    def calculate_latency(self, order_quantity):
        """
        Calculate latency based on order quantity.

        Parameters:
        order_quantity - The quantity of the order.

        Returns:
        Latency amount.
        """
        # Define latency factors (adjust these values as needed)
        base_latency = 0.001  # Base latency amount
        latency_per_unit_size = 0.00005  # Latency per unit of order size
        max_latency = 0.01  # Maximum latency allowed

        # Calculate latency amount based on order quantity
        latency_from_size = order_quantity * latency_per_unit_size

        # Combine base latency and latency from order size
        total_latency = base_latency + latency_from_size

        # Ensure latency doesn't exceed the maximum allowed
        total_latency = min(total_latency, max_latency)

        return total_latency
       

        








<<<<<<< HEAD
        return order_quantity * slippage_per_unit_size + market_volatility * slippage_per_unit_volatility
>>>>>>> d6cf693 (addmarket volatility and slippage to execute order)
=======
>>>>>>> f8144ee (calculate market impact and slippage)
